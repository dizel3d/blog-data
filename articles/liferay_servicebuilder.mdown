# Liferay Service Builder

Иногда стандартной схемы данных Liferay бывает недостаточно. И вам надо расширить ее своими таблицами. Для этого есть ServiceBuilder. 
ServiceBuilder это средство для автоматической генерации интерфейсов и классов собственного сервиса.

Первым делом поставим задачу. Давайте напишем портлет - гостевую книгу, и хоть это понятие давно устарело, данный пример можно будет расширить под что-то более полезное. 
Данный портлет будет выполнять следующие функции:
* Отображение всех сообщений
* Добавление новых сообщений

Для простоты интерфейс мы сделаем на Vaadin. Как настроить и создать простой портлет, я рассказал в [этой статье](http://dimafeng.appspot.com/show/lifera_plus_vaadin).

## ServiceBuilder

Первым делом опишем модель данных. Для хранения сообщения нам нужна таблица, которая будет содержать:
* Текст сообщения
* Дату сообщения
* Идентификатор пользователя

Теперь перейдем к созданию портлета (почитать можно [тут](http://dimafeng.appspot.com/show/lifera_plus_vaadin)). Далее правый клик на дереве проекта -> New -> Other

[!1!]

Заполняем поля, как показано на скриншоте

[!2!]

После этого должен появится файл *docroot/WEB-INF/service.xml*. Откроем его в режиме source и исправим содержимое на следующее:

<code>

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE service-builder PUBLIC "-//Liferay//DTD Service Builder 6.1.0//EN" "http://www.liferay.com/dtd/liferay-service-builder_6_1_0.dtd">
	<service-builder package-path="ru.dimafeng.ads">
		<author>dimafeng</author>
		<namespace>ADS</namespace>

		<entity name="Message" local-service="true" remote-service="false">

			<column name="messageId" type="long" primary="true" />
			<column name="userId" type="long" />
			<column name="createDate" type="Date" />
			<column name="content" type="String" />

			<!-- Order -->

			<order by="asc">
				<order-column name="messageId" />
			</order>

			<!-- Finder methods -->

			<finder name="U" return-type="Collection">
				<finder-column name="userId" />
			</finder>
		</entity>
	</service-builder>

</code>

Данный xml описывает нашу модель данных, по ней будет создана сущьность Message, hibernate-маппинг, сервис и все вспомогательные классы. 

Строчки ниже создают индекс на колонку userId

<code>

	<finder name="U" return-type="Collection">
		<finder-column name="userId" />
	</finder>

</code>

Теперь перетащите build.xml на отоброжение Ant

[!3!]

И выполните таску *build-service*, после завершения, обновите дерево проекта. Вы должны увидеть примерно следующую структуру:

[!4!]

Теперь приступим к написанию логики сервиса. Вся логика располагается в классе MessageLocalServiceImpl. 

<code>

	package ru.dimafeng.ads.service.impl;

	import java.util.Date;
	import java.util.List;

	import ru.dimafeng.ads.AdsApplication;
	import ru.dimafeng.ads.model.Message;
	import ru.dimafeng.ads.service.base.MessageLocalServiceBaseImpl;

	import com.liferay.portal.kernel.exception.SystemException;
	import com.liferay.portal.kernel.log.Log;
	import com.liferay.portal.kernel.log.LogFactoryUtil;

	public class MessageLocalServiceImpl extends MessageLocalServiceBaseImpl {

		private static Log _log = LogFactoryUtil
				.getLog(MessageLocalServiceImpl.class);

		public Message addMessage(long userId, String content)
				throws SystemException {
			_log.info(userId + " " + content);
			try {
				long entryId = counterLocalService.increment();

				Message message = messagePersistence.create(entryId);
				message.setCreateDate(new Date());
				message.setUserId(entryId);
				message.setContent(content);

				messagePersistence.update(message, false);
				
				return message;
			} catch (Exception e) {
				_log.fatal(e.getMessage(), e);
				throw new SystemException(e);
			}
		}

		public List<Message> getMessages(int start, int end) throws SystemException {
			return messagePersistence.findAll(start, end);
		}
	}

</code>

После этого надо сново выполнить таску *build-service*, чтобы сгенерировать все вспомогательные классы и обновить проект. Теперь перейдем к созданию интерфейса. Откроем AdsApplication.java.
